# 单例设计模式（Singleton Design Pattern）
## 疑问
* 为什么要使用单例？
* 单例存在哪些问题？
* 单例与静态类的区别？
* 有何替代的解决方案？
## 单例设计模式：
* 一个类只允许创建一个对象（或者实例），那这个类就是一个单例类
## 为什么要使用单例设计模式
## 实战案例一：处理资源访问冲突
* logger
* UserController
* OrderController

## 实战案例二：标识全局唯一类
* 如ID生成器

## 如何实现一个单例类
* 构造函数需要是 private 访问权限的，这样才能避免外部通过new创建实例
* 考虑对象创建时的线程安全问题
* 考虑是否支持懒加载
* 考虑getInstance() 性能是否高（是否加锁）。
### 1、饿汉式
* 饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过这样的实现方式不支持延迟加载（在真正用到的时候，再创建实例）
* 具体代码见 饿汉式单例模式
* 缺点：因为不支持延时加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。
* 反驳：
    * 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）
    * 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。
### 2、懒汉式
* 懒汉式相对于饿汉式的优势是支持延迟加载
#### 双重检索模式
* 详细代码请看 IdGenerator1
### 3、静态内部类
* 他有点类似饿汉式，但又做到了延迟加载
* 详细代码见 IdGenerator2
### 4、枚举
* 这种实现方式通过 java 枚举类类型本身的特性，保证了实例创建的线程安全性和实例的唯一性
* 具体代码见 IDGenerator3

## 单例存在哪些问题：
### 1、单例对 OOP（面向对象编程）的支持性不好
*  OOP 的四大特性：封装、抽象、继承、多态。单例这种设计模式对于其中的 抽象、继承、多态都支持的不好。
*  当我们希望针对不同的业务采用不同的 ID 生成算法时，需要将所有用到 ID 生成器的地方进行修改
*  除此之外，单例对继承、多态特性的支持也“不友好”。 不友好的原因是，单例模式理论上来说，单例类也可以被继承，也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。

### 2、单例类会隐藏类之间的依赖关系
* 

### 3、单例类对代码的扩展性不友好
* 在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行
* 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。

### 4、单例代码的可测试性不友好
* 单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。

### 5、单例不支持有参的构造函数
 
 
 
## 分布式单例模式
* 具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。
* 进程在使用这个单例对象的时候，需要先从外部共享区中将它读取到内存，并反序列化对象，然后再使用，使用完成之后还需要再存储回外部共享区域
* 为了保证任何时刻，在进程间只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其它进程再将其获取。再进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对象的加锁
* 具体代码见  IDGenerator4 此处是伪代码，具体实现还需自己处理，此处需要使用分布式锁